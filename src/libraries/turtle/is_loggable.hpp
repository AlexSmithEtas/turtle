//
//  Copyright Mathieu Champlon 2011
//
//  Distributed under the Boost Software License, Version 1.0. (See
//  accompanying file LICENSE_1_0.txt or copy at
//  http://www.boost.org/LICENSE_1_0.txt)
//

#ifndef MOCK_IS_FORMATABLE_HPP_INCLUDED
#define MOCK_IS_FORMATABLE_HPP_INCLUDED

#include "yes_no_type.hpp"
#include <boost/mpl/bool.hpp>

#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable: 4913 )
#endif

namespace mock
{
namespace detail
{
    struct sink
    {
        template< typename T >
        sink( const T& );
    };
}

    template< typename S >
    detail::no_type log( S&, detail::sink );

namespace detail
{
namespace loggable
{
    template< typename S, typename T >
    struct impl
    {
        static S* s;
        static T* t;
        // if an error is generated by the line below it means T has more than
        // one conversion to other types which are loggable : the easiest
        // solution would be to add a mock::log function for T as well.
        enum { value = sizeof( yes_type(), ::mock::log( *s, *t ), yes_type() ) == sizeof( yes_type ) };
    };
}
    template< typename S, typename T >
    struct is_loggable
        : boost::mpl::bool_< loggable::impl< S, T >::value >
    {};
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif

#endif // #ifndef MOCK_IS_FORMATABLE_HPP_INCLUDED
