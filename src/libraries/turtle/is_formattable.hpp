//
//  Copyright Mathieu Champlon 2011
//
//  Distributed under the Boost Software License, Version 1.0. (See
//  accompanying file LICENSE_1_0.txt or copy at
//  http://www.boost.org/LICENSE_1_0.txt)
//

#ifndef MOCK_IS_FORMATABLE_HPP_INCLUDED
#define MOCK_IS_FORMATABLE_HPP_INCLUDED

#include "yes_no_type.hpp"
#include "sink.hpp"
#include <boost/mpl/bool.hpp>

#ifdef _MSC_VER
#pragma warning( push )
#pragma warning( disable: 4913 )
#endif

namespace mock
{
namespace detail
{
namespace formattable
{
    template< typename S >
    detail::yes_type format( S&, detail::sink );

    template< typename S, typename T >
    struct impl
    {
        static S* s;
        static T* t;
        // if an error is generated by the line below it means T has more than
        // one conversion to other types which are formattable : the easiest
        // solution would be to add a format function for T as well.
        enum { value = sizeof( yes_type(), format( *s, *t ), yes_type() ) == sizeof( yes_type ) };
    };
}
    template< typename S, typename T >
    struct is_formattable
        : boost::mpl::bool_< formattable::impl< S, T >::value >
    {};
}
}

#ifdef _MSC_VER
#pragma warning( pop )
#endif

#endif // #ifndef MOCK_IS_FORMATABLE_HPP_INCLUDED
