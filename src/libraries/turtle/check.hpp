//
//  Copyright Mathieu Champlon 2008
//
//  Distributed under the Boost Software License, Version 1.0. (See
//  accompanying file LICENSE_1_0.txt or copy at
//  http://www.boost.org/LICENSE_1_0.txt)
//

#ifndef MOCK_CHECK_HPP_INCLUDED
#define MOCK_CHECK_HPP_INCLUDED

#include "config.hpp"
#include "is_functor.hpp"
#include "constraints.hpp"
#include "operators.hpp"
#include "format.hpp"
#include <boost/utility/enable_if.hpp>
#include <boost/concept_check.hpp>
#ifdef MOCK_USE_BOOST_BIND
#include <boost/bind.hpp>
#else
#include <boost/spirit/home/phoenix/bind.hpp>
#include <boost/spirit/home/phoenix/core/argument.hpp>
#endif
#include <boost/function.hpp>
#include <stdexcept>
#include <ostream>

namespace mock
{
namespace detail
{
    template< typename Functor, typename Actual >
    struct FunctorCompatible : private boost::noncopyable
    {
    public:
        BOOST_CONCEPT_USAGE( FunctorCompatible )
        {
            boost::require_boolean_expr(
                // if an error is generated by the line below it means
                // an argument passed to 'with' was of the wrong type.
                functor_accepts( actual_argument_type )
            );
        }
    private:
        FunctorCompatible( int ) {}
        Functor functor_accepts;
        Actual actual_argument_type;
    };

    template< typename Expected, typename Actual >
    struct EqualityComparable : private boost::noncopyable
    {
    public:
        BOOST_CONCEPT_USAGE( EqualityComparable )
        {
            boost::require_boolean_expr(
                // if an error is generated by the line below it means
                // an argument passed to 'with' was of the wrong type.
                actual_argument_type == expected_argument_type
            );
        }
    private:
        EqualityComparable( int ) {}
        Expected expected_argument_type;
        Actual actual_argument_type;
    };

    template< typename T >
    void log( std::ostream& s, const T& t )
    {
        s << mock::format( t );
    }

#ifdef MOCK_USE_BOOST_BIND
    template< typename T >
    boost::function< void( std::ostream& ) > lazy_format( T t )
    {
        return boost::bind( &log< T >, _1, t );
    }
#else
    template< typename T >
    boost::function< void( std::ostream& ) > lazy_format( T t )
    {
        return boost::phoenix::bind(
            &log< T >,
            boost::phoenix::arg_names::_1, t );
    }
#endif

    template< typename Actual >
    class check
    {
    public:
        template< typename Functor >
        explicit check( const Functor& f,
            BOOST_DEDUCED_TYPENAME boost::enable_if<
                    BOOST_DEDUCED_TYPENAME detail::is_functor< Functor >
            >::type* = 0 )
            : desc_( lazy_format( f ) )
        {
            BOOST_CONCEPT_ASSERT(( FunctorCompatible< Functor, Actual > ));
            f_ = f;
            if( ! f_ )
                std::invalid_argument( "invalid constraint" );
        }
        template< typename Expected >
        explicit check( const Expected& expected,
            BOOST_DEDUCED_TYPENAME boost::disable_if<
                    BOOST_DEDUCED_TYPENAME detail::is_functor< Expected >
            >::type* = 0 )
            : desc_( lazy_format( expected ) )
        {
            BOOST_CONCEPT_ASSERT(( EqualityComparable< Expected, Actual > ));
            f_ = mock::equal( expected ).f_;
            if( ! f_ )
                std::invalid_argument( "invalid constraint" );
        }
        template< typename Constraint >
        explicit check( const constraint< Constraint >& c )
            : desc_( lazy_format( c.f_ ) )
        {
            BOOST_CONCEPT_ASSERT(( FunctorCompatible< Constraint, Actual > ));
            f_ = c.f_;
            if( ! f_ )
                std::invalid_argument( "invalid constraint" );
        }

        bool operator()( Actual actual ) const
        {
            return f_( actual );
        }

        friend std::ostream& operator<<( std::ostream& s, const check& c )
        {
            c.desc_( s );
            return s;
        }

    private:
        boost::function< bool( Actual ) > f_;
        boost::function< void( std::ostream& ) > desc_;
    };
}
}

#endif // #ifndef MOCK_CHECK_HPP_INCLUDED
