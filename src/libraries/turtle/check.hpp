//
//  Copyright Mathieu Champlon 2008
//
//  Distributed under the Boost Software License, Version 1.0. (See
//  accompanying file LICENSE_1_0.txt or copy at
//  http://www.boost.org/LICENSE_1_0.txt)
//

#ifndef MOCK_CHECK_HPP_INCLUDED
#define MOCK_CHECK_HPP_INCLUDED

#include "placeholder.hpp"
#include "constraint.hpp"
#include "is_functor.hpp"
#include "format.hpp"
#include <boost/function.hpp>
#include <boost/utility/enable_if.hpp>
#include <boost/concept/assert.hpp>
#include <boost/concept_check.hpp>
#include <stdexcept>
#include <ostream>

namespace mock
{
namespace detail
{
    template< typename Constraint, typename Actual >
    struct ConstraintCompatible : private boost::noncopyable
    {
    public:
        BOOST_CONCEPT_USAGE( ConstraintCompatible )
        {
            // if an error is generated by the line below it means an argument
            // passed to 'with' was of the wrong type.
            constraint_accepts( actual_argument_type );
        }
    private:
        ConstraintCompatible( int ) {}
        Constraint constraint_accepts;
        Actual actual_argument_type;
    };

    template< typename Expected, typename Actual >
    struct EqualityComparable : private boost::noncopyable
    {
    public:
        BOOST_CONCEPT_USAGE( EqualityComparable )
        {
            boost::require_boolean_expr(
                // if an error is generated by the line below it means an argument
                // passed to 'with' was of the wrong type.
                actual_argument_type == expected_argument_type
            );
        }
    private:
        EqualityComparable( int ) {}
        Expected expected_argument_type;
        Actual actual_argument_type;
    };

    template< typename Actual >
    class check
    {
        typedef BOOST_DEDUCED_TYPENAME
            boost::function< bool( Actual ) > constraint_type;

    public:
        template< typename Constraint >
        explicit check( const Constraint& constraint,
            BOOST_DEDUCED_TYPENAME boost::enable_if<
                BOOST_DEDUCED_TYPENAME detail::is_functor< Constraint >
            >::type* = 0 )
            : desc_( "?" )
        {
            BOOST_CONCEPT_ASSERT(( ConstraintCompatible< Constraint, Actual > ));
            constraint_ = constraint;
            if( !constraint_ )
                std::invalid_argument( "invalid constraint" );
        }
        template< typename Expected >
        explicit check( const Expected& expected,
            BOOST_DEDUCED_TYPENAME boost::disable_if<
                BOOST_DEDUCED_TYPENAME detail::is_functor< Expected >
            >::type* = 0 )
            : desc_( format( expected ) )
        {
            BOOST_CONCEPT_ASSERT(( EqualityComparable< Expected, Actual > ));
            constraint_ = mock::equal( expected ).constraint_;
            if( !constraint_ )
                std::invalid_argument( "invalid constraint" );
        }
        template< typename Constraint >
        explicit check( const placeholder< Constraint >& ph )
            : desc_( ph.desc_ )
        {
            BOOST_CONCEPT_ASSERT(( ConstraintCompatible< Constraint, Actual > ));
            constraint_ = ph.constraint_;
            if( !constraint_ )
                std::invalid_argument( "invalid constraint" );
        }

        bool operator()( Actual actual ) const
        {
            return constraint_( actual );
        }

        friend std::ostream& operator<<( std::ostream& s, const check& c )
        {
            return s << c.desc_;
        }

    private:
        constraint_type constraint_;
        std::string desc_;
    };
}
}

#endif // #ifndef MOCK_CHECK_HPP_INCLUDED
