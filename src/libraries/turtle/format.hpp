//
//  Copyright Mathieu Champlon 2008
//
//  Distributed under the Boost Software License, Version 1.0. (See
//  accompanying file LICENSE_1_0.txt or copy at
//  http://www.boost.org/LICENSE_1_0.txt)
//

#ifndef MOCK_FORMAT_HPP_INCLUDED
#define MOCK_FORMAT_HPP_INCLUDED

#include "is_serializable.hpp"
#include "is_formattable.hpp"
#include <boost/function_types/is_callable_builtin.hpp>
#include <boost/utility/enable_if.hpp>
#include <boost/mpl/has_xxx.hpp>
#include <boost/mpl/not.hpp>
#include <boost/mpl/and.hpp>
#include <boost/mpl/or.hpp>
#include <utility>
#include <ostream>
#include <string>

namespace mock
{
namespace detail
{
    template< typename T >
    void serialize( std::ostream& s, const T& t,
        BOOST_DEDUCED_TYPENAME boost::enable_if<
            BOOST_DEDUCED_TYPENAME detail::is_formattable< std::ostream, T >
        >::type* = 0 )
    {
        format( s, t );
    }
    template< typename T >
    void serialize( std::ostream& s, const T& t,
        BOOST_DEDUCED_TYPENAME boost::enable_if<
            boost::mpl::and_<
                boost::mpl::not_<
                    BOOST_DEDUCED_TYPENAME detail::is_formattable< std::ostream, T >
                >,
                BOOST_DEDUCED_TYPENAME detail::is_serializable< std::ostream, T >
            >
        >::type* = 0 )
    {
        s << t;
    }
    template< typename T >
    void serialize( std::ostream& s, const T&,
        BOOST_DEDUCED_TYPENAME boost::disable_if<
            boost::mpl::or_<
                BOOST_DEDUCED_TYPENAME detail::is_formattable< std::ostream, T >,
                BOOST_DEDUCED_TYPENAME detail::is_serializable< std::ostream, T >
            >
        >::type* = 0 )
    {
        s << '?';
    }

    BOOST_MPL_HAS_XXX_TRAIT_NAMED_DEF(is_container, const_iterator, false)
}

    template< typename T >
    class formatter
    {
    public:
        explicit formatter( const T& t )
            : t_( &t )
        {}
        const T& operator*() const
        {
            return *t_;
        }
        const T* operator->() const
        {
            return t_;
        }
    private:
        const T* t_;
    };

    template< typename T >
    formatter< T > format( const T& t )
    {
        return formatter< T >( t );
    }

    template< typename T >
    BOOST_DEDUCED_TYPENAME boost::disable_if<
        detail::is_container< T >,
        std::ostream&
    >::type
    operator<<( std::ostream& s, const formatter< T >& f )
    {
        detail::serialize( s, *f );
        return s;
    }

    inline std::ostream& operator<<( std::ostream& s, const formatter< bool >& f )
    {
        return s << std::boolalpha << *f;
    }
    inline std::ostream& operator<<( std::ostream& s, const formatter< std::string >& f )
    {
        return s << '"' << *f << '"';
    }
    inline std::ostream& operator<<( std::ostream& s, const formatter< const char* >& f )
    {
        return s << '"' << *f << '"';
    }

    template< typename T1, typename T2 >
    std::ostream& operator<<( std::ostream& s, const formatter< std::pair< T1, T2 > >& f )
    {
        return s << '(' << mock::format( f->first )
            << ',' << mock::format( f->second ) << ')';
    }

    template< typename T >
    BOOST_DEDUCED_TYPENAME boost::enable_if<
        boost::function_types::is_callable_builtin< T* >,
        std::ostream&
    >::type
    operator<<( std::ostream& s, const formatter< T* >& )
    {
        return s << '?';
    }

    template< typename T >
    BOOST_DEDUCED_TYPENAME boost::enable_if<
        detail::is_container< T >,
        std::ostream&
    >::type
    operator<<( std::ostream& s, const formatter< T >& f )
    {
        s << '(';
        // if an error is generated by the line below it means T is
        // being mismatched for a container because it has a typedef
        // const_iterator : the solution would be to add a serialization
        // operator for mock::formatter< T >.
        for( BOOST_DEDUCED_TYPENAME T::const_iterator it = f->begin();
            it != f->end(); ++it )
        {
            if( it != f->begin() )
                s << ',';
            s << mock::format( *it );
        }
        return s << ')';
    }
}

#endif // #ifndef MOCK_FORMAT_HPP_INCLUDED
