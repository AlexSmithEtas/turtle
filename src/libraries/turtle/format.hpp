//
//  Copyright Mathieu Champlon 2008
//
//  Distributed under the Boost Software License, Version 1.0. (See
//  accompanying file LICENSE_1_0.txt or copy at
//  http://www.boost.org/LICENSE_1_0.txt)
//

#ifndef MOCK_FORMAT_HPP_INCLUDED
#define MOCK_FORMAT_HPP_INCLUDED

#include "is_serializable.hpp"
#include "is_formattable.hpp"
#include <boost/function_types/is_callable_builtin.hpp>
#include <boost/utility/enable_if.hpp>
#include <utility>
#include <ostream>
#include <string>

namespace mock
{
    template< typename T >
    class formatter
    {
    public:
        explicit formatter( const T& t )
            : t_( &t )
        {}
        const T& operator*() const
        {
            return *t_;
        }
        const T* operator->() const
        {
            return t_;
        }
    private:
        const T* t_;
    };

namespace detail
{
    template< typename T >
    void serialize( std::ostream& s, const T& t,
        BOOST_DEDUCED_TYPENAME boost::enable_if<
            BOOST_DEDUCED_TYPENAME protect::is_serializable< std::ostream, T > >::type* = 0 )
    {
        s << t;
    }
    template< typename T >
    void serialize( std::ostream& s, const T&,
        BOOST_DEDUCED_TYPENAME boost::disable_if<
            BOOST_DEDUCED_TYPENAME protect::is_serializable< std::ostream, T > >::type* = 0 )
    {
        s << "?";
    }
}

    template< typename T >
    BOOST_DEDUCED_TYPENAME boost::enable_if<
        BOOST_DEDUCED_TYPENAME mock::detail::is_formattable< std::ostream, T >,
        std::ostream&
    >::type
    operator<<( std::ostream& s, const formatter< T >& f )
    {
        format( s, *f );
        return s;
    }
    template< typename T >
    BOOST_DEDUCED_TYPENAME boost::disable_if<
        BOOST_DEDUCED_TYPENAME mock::detail::is_formattable< std::ostream, T >,
        std::ostream&
    >::type
    operator<<( std::ostream& s, const formatter< T >& f )
    {
        mock::detail::serialize( s, *f );
        return s;
    }

    inline std::ostream& operator<<( std::ostream& s, const formatter< bool >& f )
    {
        return s << std::boolalpha << *f;
    }
    inline std::ostream& operator<<( std::ostream& s, const formatter< std::string >& f )
    {
        return s << '"' << *f << '"';
    }
    inline std::ostream& operator<<( std::ostream& s, const formatter< const char* >& f )
    {
        return s << '"' << *f << '"';
    }

    template< typename T >
    formatter< T > format( const T& t )
    {
        return formatter< T >( t );
    }

    template< typename Container >
    void format( std::ostream& s, const Container& c,
        BOOST_DEDUCED_TYPENAME Container::const_iterator* = 0 )
    {
        s << '(';
        // if an error is generated by the line below it means Container is
        // being mismatched for a container because it has a typedef
        // const_iterator : the easiest solution would be to add a format
        // function for Container as well.
        for( BOOST_DEDUCED_TYPENAME Container::const_iterator it = c.begin();
            it != c.end(); ++it )
        {
            if( it != c.begin() )
                s << ',';
            s << mock::format( *it );
        }
        s << ')';
    }

    template< typename T1, typename T2 >
    void format( std::ostream& s, const std::pair< T1, T2 >& p )
    {
         s << '(' << mock::format( p.first )
             << ',' << mock::format( p.second ) << ')';
    }

    template< typename T >
    void format( std::ostream& s, T,
        BOOST_DEDUCED_TYPENAME boost::enable_if<
            BOOST_DEDUCED_TYPENAME
                boost::function_types::is_callable_builtin< T > >::type* = 0 )
    {
         s << '?';
    }
}

#endif // #ifndef MOCK_FORMAT_HPP_INCLUDED
