//
//  Copyright Mathieu Champlon 2008
//
//  Distributed under the Boost Software License, Version 1.0. (See
//  accompanying file LICENSE_1_0.txt or copy at
//  http://www.boost.org/LICENSE_1_0.txt)
//

#ifndef MOCK_FORMAT_HPP_INCLUDED
#define MOCK_FORMAT_HPP_INCLUDED

#include "is_serializable.hpp"
#include "is_formattable.hpp"
#include <boost/function_types/is_callable_builtin.hpp>
#include <boost/utility/enable_if.hpp>
#include <boost/mpl/has_xxx.hpp>
#include <boost/mpl/not.hpp>
#include <boost/mpl/and.hpp>
#include <boost/mpl/or.hpp>
#include <utility>
#include <ostream>
#include <string>

namespace mock
{
namespace detail
{
    template< typename T >
    void serialize( std::ostream& s, const T& t,
        BOOST_DEDUCED_TYPENAME boost::enable_if<
            BOOST_DEDUCED_TYPENAME detail::is_formattable< std::ostream, T >
        >::type* = 0 )
    {
        format( s, t );
    }
    template< typename T >
    void serialize( std::ostream& s, const T& t,
        BOOST_DEDUCED_TYPENAME boost::enable_if<
            boost::mpl::and_<
                boost::mpl::not_<
                    BOOST_DEDUCED_TYPENAME detail::is_formattable< std::ostream, T >
                >,
                BOOST_DEDUCED_TYPENAME detail::is_serializable< std::ostream, T >
            >
        >::type* = 0 )
    {
        s << t;
    }
    template< typename T >
    void serialize( std::ostream& s, const T&,
        BOOST_DEDUCED_TYPENAME boost::disable_if<
            boost::mpl::or_<
                BOOST_DEDUCED_TYPENAME detail::is_formattable< std::ostream, T >,
                BOOST_DEDUCED_TYPENAME detail::is_serializable< std::ostream, T >
            >
        >::type* = 0 )
    {
        s << '?';
    }

    BOOST_MPL_HAS_XXX_TRAIT_NAMED_DEF(is_container, const_iterator, false)
}

    template< typename T >
    class protect
    {
    public:
        explicit protect( const T& t )
            : t_( &t )
        {}
        const T& operator*() const
        {
            return *t_;
        }
        const T* operator->() const
        {
            return t_;
        }
    private:
        const T* t_;
    };
    template< typename T >
    std::ostream& operator<<( std::ostream& s, protect< T > t )
    {
        format( s, t );
        return s;
    }

    template< typename T >
    protect< T > format( const T& t )
    {
        return protect< T >( t );
    }

    template< typename T >
    void format( std::ostream& s, protect< T > t,
        BOOST_DEDUCED_TYPENAME boost::disable_if<
            detail::is_container< T >
        >::type* = 0 )
    {
        detail::serialize( s, *t );
    }

    inline void format( std::ostream& s, protect< bool > b )
    {
        s << std::boolalpha << *b;
    }
    inline void format( std::ostream& s, protect< std::string > str )
    {
        s << '"' << *str << '"';
    }
    inline void format( std::ostream& s, protect< const char* > str )
    {
        s << '"' << *str << '"';
    }

    template< typename T1, typename T2 >
    void format( std::ostream& s, protect< std::pair< T1, T2 > > p )
    {
        s << '(' << mock::format( p->first )
            << ',' << mock::format( p->second ) << ')';
    }

    template< typename T >
    void format( std::ostream& s, protect< T* >,
        BOOST_DEDUCED_TYPENAME boost::enable_if<
            boost::function_types::is_callable_builtin< T* >
        >::type* = 0 )
    {
        s << '?';
    }

    template< typename T >
    void format( std::ostream& s, protect< T > c,
        BOOST_DEDUCED_TYPENAME boost::enable_if<
            detail::is_container< T >
        >::type* = 0 )
    {
        s << '(';
        // if an error is generated by the line below it means T is
        // being mistaken for a container because it has a typedef
        // const_iterator : the solution would be to add a format override
        // for mock::protect< T >.
        for( BOOST_DEDUCED_TYPENAME T::const_iterator it = c->begin();
            it != c->end(); ++it )
        {
            if( it != c->begin() )
                s << ',';
            s << mock::format( *it );
        }
        s << ')';
    }
}

#endif // #ifndef MOCK_FORMAT_HPP_INCLUDED
